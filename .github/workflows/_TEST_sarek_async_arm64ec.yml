name: sarek-async-arm64ec test

on:
  workflow_dispatch:
    inputs:
      upload_artifacts:
        description: "Upload all reports and dlls"
        type: boolean
        default: true

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  UPSTREAM_REPO: pythonlover02/DXVK-Sarek
  UPSTREAM_BRANCH: async
  TOOLCHAIN_URL: https://github.com/bylaws/llvm-mingw/releases/download/20250305/llvm-mingw-20250305-ucrt-ubuntu-20.04-x86_64.tar.xz
  # Optional: set TOOLCHAIN_SHA256 to enforce archive integrity
  TOOLCHAIN_SHA256: ''

jobs:
  build-ec:
    name: Build ARM64EC + static checks
    runs-on: ubuntu-24.04
    timeout-minutes: 60
    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4

      - name: System deps
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            ninja-build meson python3 \
            glslang-tools ca-certificates curl xz-utils \
            pkgconf jq git llvm

      - name: Checkout upstream DXVK-Sarek
        uses: actions/checkout@v4
        with:
          repository: ${{ env.UPSTREAM_REPO }}
          ref: ${{ env.UPSTREAM_BRANCH }}
          submodules: recursive
          fetch-depth: 0
          path: dxvk

      - name: Download llvm-mingw (ARM64EC)
        run: |
          set -euo pipefail
          mkdir -p "$HOME/toolchain"
          curl -L "${{ env.TOOLCHAIN_URL }}" -o /tmp/llvm-mingw.tar.xz
          if [ -n "${{ env.TOOLCHAIN_SHA256 }}" ]; then
            echo "${{ env.TOOLCHAIN_SHA256 }}  /tmp/llvm-mingw.tar.xz" | sha256sum -c -
          fi
          tar -xJf /tmp/llvm-mingw.tar.xz -C "$HOME/toolchain" --strip-components=1
          echo "PATH=$HOME/toolchain/bin:$PATH" >> "$GITHUB_ENV"
          echo "$HOME/toolchain/bin" >> "$GITHUB_PATH"
          {
            echo "CC=arm64ec-w64-mingw32-clang";
            echo "CXX=arm64ec-w64-mingw32-clang++";
            echo "AR=arm64ec-w64-mingw32-ar";
            echo "RC=arm64ec-w64-mingw32-windres";
            echo "WIDL=arm64ec-w64-mingw32-widl";
            echo "DLLTOOL=arm64ec-w64-mingw32-dlltool";
          } >> "$GITHUB_ENV"

      - name: Probes (compiler + macros)
        run: |
          set -euo pipefail
          which arm64ec-w64-mingw32-clang++
          arm64ec-w64-mingw32-clang++ --version
          echo '== macros =='
          arm64ec-w64-mingw32-clang++ -dM -E - < /dev/null | \
            egrep -E '__arm64ec__|_M_ARM64EC|__aarch64__|__x86_64__|_M_X64|_M_AMD64' || true

      - name: Generate Meson cross file
        working-directory: dxvk
        run: |
          set -euo pipefail
          cat > arm64ec.meson <<'EOF'
          [binaries]
          ar = 'arm64ec-w64-mingw32-ar'
          c = 'arm64ec-w64-mingw32-clang'
          cpp = 'arm64ec-w64-mingw32-clang++'
          windres = 'arm64ec-w64-mingw32-windres'
          widl = 'arm64ec-w64-mingw32-widl'
          strip = 'llvm-strip'

          [host_machine]
          system = 'windows'
          cpu_family = 'aarch64'
          cpu = 'aarch64'
          endian = 'little'

          [built-in options]
          c_args  = ['-DSAREK_ARM64EC=1','-D__CRT__NO_INLINE=1','-fno-fast-math','-ffp-contract=off']
          cpp_args= ['-DSAREK_ARM64EC=1','-D__CRT__NO_INLINE=1','-fno-fast-math','-ffp-contract=off']
          c_link_args   = ['-fuse-ld=lld']
          cpp_link_args = ['-fuse-ld=lld']
          b_linker = 'lld'
          EOF
          nl -ba arm64ec.meson

      - name: Patch for ARM64EC (shim + guards + bitops)
        working-directory: dxvk
        shell: bash
        run: |
          set -euo pipefail

          # 0) SSE shim header (NEON + scalar fallback)
          mkdir -p include
          cat > include/sarek_arm64ec_sse_shim.h <<'SHIM'
          #pragma once
          #if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)
          #include <cstdint>
          #include <cstring>
          #if defined(__aarch64__) || defined(__arm64ec__) || defined(_M_ARM64EC)
            #include <arm_neon.h>
            typedef float32x4_t __m128;
            typedef uint8x16_t  __m128i;
            static inline void _mm_pause(void) { __asm__ __volatile__("yield" ::: "memory"); }
            static inline __m128 _mm_loadu_ps(const float* p){ return vld1q_f32(p); }
            static inline void   _mm_storeu_ps(float* p, __m128 a){ vst1q_f32(p, a); }
            static inline __m128 _mm_cmpeq_ps(__m128 a, __m128 b){ return vreinterpretq_f32_u32(vceqq_f32(a, b)); }
            static inline __m128 _mm_and_ps(__m128 a, __m128 b){ return vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(a), vreinterpretq_u32_f32(b))); }
            static inline __m128i _mm_setzero_si128(){ return vdupq_n_u8(0); }
            static inline __m128i _mm_set1_epi8(int x){ return vdupq_n_u8((uint8_t)x); }
            static inline __m128i _mm_load_si128 (const __m128i* p){ return vld1q_u8((const uint8_t*)p); }
            static inline __m128i _mm_loadu_si128(const __m128i* p){ return vld1q_u8((const uint8_t*)p); }
            static inline void     _mm_store_si128 (__m128i* p, __m128i a){ vst1q_u8((uint8_t*)p, a); }
            static inline void     _mm_storeu_si128(__m128i* p, __m128i a){ vst1q_u8((uint8_t*)p, a); }
            static inline __m128i _mm_cmpeq_epi8(__m128i a, __m128i b){ return vceqq_u8(a, b); }
            static inline __m128i _mm_and_si128 (__m128i a, __m128i b){ return vandq_u8(a, b); }
            static inline __m128i _mm_or_si128  (__m128i a, __m128i b){ return vorrq_u8(a, b); }
            static inline __m128i _mm_xor_si128 (__m128i a, __m128i b){ return veorq_u8(a, b); }
            static inline int _mm_movemask_epi8(__m128i a){ alignas(16) uint8_t tmp[16]; vst1q_u8(tmp, a); int m=0; for(int i=0;i<16;i++) m|=((tmp[i]&0x80)?1:0)<<i; return m; }
          #else
            struct alignas(16) __m128  { float   v[4];  };
            struct alignas(16) __m128i { uint8_t v[16]; };
            static inline void _mm_pause(void){ __asm__ __volatile__("" ::: "memory"); }
            static inline __m128 _mm_loadu_ps(const float* p){ __m128 r; std::memcpy(r.v,p,16); return r; }
            static inline void   _mm_storeu_ps(float* p, __m128 a){ std::memcpy(p,a.v,16); }
            static inline __m128 _mm_cmpeq_ps(__m128 a,__m128 b){ __m128 r; for(int i=0;i<4;i++){ uint32_t m=(a.v[i]==b.v[i])?0xFFFFFFFFu:0u; std::memcpy(&r.v[i],&m,4);} return r; }
            static inline __m128 _mm_and_ps(__m128 a,__m128 b){ __m128 r; for(int i=0;i<4;i++){ uint32_t ai,bi,ci; std::memcpy(&ai,&a.v[i],4); std::memcpy(&bi,&b.v[i],4); ci=ai&bi; std::memcpy(&r.v[i],&ci,4);} return r; }
            static inline __m128i _mm_setzero_si128(){ __m128i r; std::memset(r.v,0,16); return r; }
            static inline __m128i _mm_set1_epi8(int x){ __m128i r; uint8_t v=(uint8_t)x; for(int i=0;i<16;i++) r.v[i]=v; return r; }
            static inline __m128i _mm_load_si128(const __m128i* p){ __m128i r; std::memcpy(&r,p,16); return r; }
            static inline __m128i _mm_loadu_si128(const __m128i* p){ return _mm_load_si128(p); }
            static inline void     _mm_store_si128(__m128i* p, __m128i a){ std::memcpy(p,&a,16); }
            static inline void     _mm_storeu_si128(__m128i* p, __m128i a){ _mm_store_si128(p,a); }
            static inline __m128i _mm_cmpeq_epi8(__m128i a,__m128i b){ __m128i r; for(int i=0;i<16;i++) r.v[i]=(a.v[i]==b.v[i])?0xFF:0x00; return r; }
            static inline __m128i _mm_and_si128(__m128i a,__m128i b){ __m128i r; for(int i=0;i<16;i++) r.v[i]=a.v[i]&b.v[i]; return r; }
            static inline __m128i _mm_or_si128 (__m128i a,__m128i b){ __m128i r; for(int i=0;i<16;i++) r.v[i]|=b.v[i]; return r; }
            static inline __m128i _mm_xor_si128(__m128i a,__m128i b){ __m128i r; for(int i=0;i<16;i++) r.v[i]^=b.v[i]; return r; }
            static inline int _mm_movemask_epi8(__m128i a){ int m=0; for(int i=0;i<16;i++) m|=((a.v[i]&0x80)?1:0)<<i; return m; }
          #endif
          #if defined(__SSE__) || defined(__SSE2__) || defined(__SSE3__) || defined(__SSSE3__) || \
              defined(__SSE4_1__) || defined(__SSE4_2__) || defined(__AVX__) || defined(__AVX2__)
          #error "x86 SIMD macros must not be defined on ARM64EC build"
          #endif
          #endif
          SHIM

          # 1) Prolog injection for util headers
          ARM64EC_PROLOG='#if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)
          /* SAREK on ARM64EC: disable x86/SSE/AVX paths + provide SSE shim */
          #undef __x86_64__
          #undef _M_X64
          #undef _M_AMD64
          #undef __i386__
          #undef _M_IX86
          #undef __SSE__
          #undef __SSE2__
          #undef __SSE3__
          #undef __SSSE3__
          #undef __SSE4_1__
          #undef __SSE4_2__
          #undef __AVX__
          #undef __AVX2__
          #include "sarek_arm64ec_sse_shim.h"
          #include "sarek_bitops_ec.h"
          #endif'
          for f in src/util/util_vector.h src/util/util_bit.h; do
            if [ -f "$f" ] && ! grep -q 'SAREK on ARM64EC: disable x86/SSE/AVX paths' "$f"; then
              tmp=$(mktemp); printf "%s\n" "$ARM64EC_PROLOG" > "$tmp"; cat "$f" >> "$tmp"; mv "$tmp" "$f"; fi
          done

          # 2) sync_spinlock.h shim include (idempotent)
          if [ -f src/util/sync/sync_spinlock.h ] && ! grep -q 'sarek_arm64ec_sse_shim.h' src/util/sync/sync_spinlock.h; then
            tmp=$(mktemp); { echo '#if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)'; echo '#include "sarek_arm64ec_sse_shim.h"'; echo '#endif'; cat src/util/sync/sync_spinlock.h; } > "$tmp"; mv "$tmp" src/util/sync/sync_spinlock.h; fi

          # 3) Gather file list
          find src include -type f \( -name '*.h' -o -name '*.hpp' -o -name '*.c' -o -name '*.cpp' -o -name '*.inl' \) \
            -not -path 'include/vulkan/*' -not -path 'include/spirv/*' > __filelist.txt

          # 4) Neutralize x86-only intrinsic includes (keep intrin.h)
          mapfile -t KILL_HDRS < <(xargs -a __filelist.txt grep -RInE '#\s*include\s*[<"]\s*((x86intrin|x86gprintrin|immintrin|xmmintrin|emmintrin|smmintrin|tmmintrin|pmmintrin|nmmintrin|wmmintrin))\.h\s*[>"]' 2>/dev/null | cut -d: -f1 | sort -u)
          for f in "${KILL_HDRS[@]:-}"; do
            sed -i -E \
              's@(^\s*#\s*include\s*[<"](x86intrin|x86gprintrin|immintrin|xmmintrin|emmintrin|smmintrin|tmmintrin|pmmintrin|nmmintrin|wmmintrin)\.h[>"])@/* SAREK_ARM64EC neutralized */ // REMOVED@' \
              "$f"
          done

          # 5) Patch x86 arch guards to exclude EC (wrap entire expr once; no duplicated 'defined')
          python3 - <<'PY'
          import pathlib, re
          targets = [pathlib.Path(l.strip()) for l in open('__filelist.txt') if l.strip()]
          
          x86 = ('__x86_64__','_M_X64','_M_AMD64','__i386__','_M_IX86')
          ec  = ('SAREK_ARM64EC','__arm64ec__','_M_ARM64EC')
          
          changed = 0
          pat = re.compile(r'^(\s*#\s*(?:if|elif)\s+)(.*)$', re.M)
          
          for p in targets:
              try:
                  s = p.read_text(encoding='utf-8', errors='ignore')
              except Exception:
                  continue
          
              def repl(m):
                  head, expr = m.group(1), m.group(2)
                  if any(k in expr for k in x86) and not any(k in expr for k in ec):
                      return f"{head}({expr}) && !defined(SAREK_ARM64EC) && !defined(__arm64ec__) && !defined(_M_ARM64EC)"
                  return m.group(0)
          
              ns, n = pat.subn(repl, s)
              if n:
                  p.write_text(ns, encoding='utf-8')
                  changed += n
          
          print(f"guard-patched {changed} place(s)")
          PY
          
          # 5.1) Preflight: detect malformed #if with adjacent defined(...) tokens
          if grep -RInE '^[[:space:]]*#(if|elif)[[:space:]].*defined\([^)]*\)[[:space:]]+defined\(' src include; then
            echo '::error:: malformed preprocessor condition (missing operator between defined(...))'
            exit 1
          fi

          # 6) Safer bitops helper and replacement (bsf/cmovz)
          cat > include/sarek_bitops_ec.h <<'HDR'
          #pragma once
          #include <type_traits>
          template <class T>
          static inline int sarek_ctz_or_width(T n){
            using U = typename std::make_unsigned<T>::type;
            if(!n) return sizeof(U)*8;
            if constexpr (sizeof(U) <= 4) return __builtin_ctz((unsigned)(U)n);
            else return __builtin_ctzll((unsigned long long)(U)n);
          }
          HDR
          # 6.1) Ensure util_bit.h includes bitops header (idempotent)
          if ! grep -q 'sarek_bitops_ec.h' src/util/util_bit.h; then
            tmp=$(mktemp)
            { echo '#if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)';
              echo '#include "sarek_bitops_ec.h"';
              echo '#endif';
              cat src/util/util_bit.h; } > "$tmp"
            mv "$tmp" src/util/util_bit.h
          fi
          python3 - <<'PY'
          import re, pathlib
          p = pathlib.Path('src/util/util_bit.h')
          s = p.read_text(encoding='utf-8', errors='ignore')
          pat = re.compile(r'(?P<asm>(?:__asm__|asm)\s*(?:volatile\s*)?\(.*?\)\s*;)', re.I|re.S)
          def wrap(m):
            block = m.group('asm'); low = block.lower()
            if 'bsf' in low or 'cmovz' in low:
              return (
                '#if defined(SAREK_ARM64EC) || defined(__arm64ec__) || defined(_M_ARM64EC)\n'
                '      /* ARM64EC: replace x86 asm (bsf/cmovz) with width-preserving builtin */\n'
                '      res = sarek_ctz_or_width(n);\n'
                '      tmp = (n==0) ? 1 : 0; (void)tmp;\n'
                '#else\n' + block + '\n#endif\n'
              )
            return block
          ns, n = pat.subn(wrap, s)
          if n == 0:
            raise SystemExit('::error:: could not find x86 asm block with bsf/cmovz to replace in util_bit.h')
          p.write_text(ns, encoding='utf-8')
          print(f'patched util_bit.h: replaced {n} asm block(s)')
          PY

          # 7) D3D9 compat include
          cat > include/sarek_d3d9_compat.h <<'HDR'
          #pragma once
          #if defined(__has_include)
          # if __has_include(<d3d9.h>)
          #  include <d3d9.h>
          # endif
          #endif
          #ifndef D3DDEVINFO_RESOURCEMANAGER
          #define D3DDEVINFO_RESOURCEMANAGER D3DDEVINFO_D3DRESOURCEMANAGER
          #endif
          #ifndef D3DDEVINFO_VERTEXSTATS
          #define D3DDEVINFO_VERTEXSTATS D3DDEVINFO_D3DVERTEXSTATS
          #endif
          HDR
          if [ -f src/d3d9/d3d9_include.h ]; then
            if ! grep -q 'sarek_d3d9_compat.h' src/d3d9/d3d9_include.h; then
              tmp=$(mktemp); { echo '#include "sarek_d3d9_compat.h"'; cat src/d3d9/d3d9_include.h; } > "$tmp"; mv "$tmp" src/d3d9/d3d9_include.h
            else
              sed -i '1,16{s|#include <sarek_d3d9_compat.h>|#include "sarek_d3d9_compat.h"|}' src/d3d9/d3d9_include.h || true
            fi
          fi

          # 8) Preprocess probe: ban x86-only headers & asm 'bsf'
          CXX=arm64ec-w64-mingw32-clang++
          BASE='-std=c++17 -DSAREK_ARM64EC=1 -D__CRT__NO_INLINE=1 -D_FILE_OFFSET_BITS=64 -D_WIN32_WINNT=0x0A00 -DDXVK_WSI_WIN32 -I. -Isrc -Iinclude -fno-fast-math -ffp-contract=off'
          echo '#include "src/util/util_bit.h"' > __pp_probe.cpp
          $CXX -E -x c++ -P $BASE __pp_probe.cpp > __pp_probe.i
          if egrep -q '(immintrin|x86intrin|xmmintrin|emmintrin|smmintrin|tmmintrin|pmmintrin|nmmintrin|wmmintrin)\.h' __pp_probe.i; then
            echo '::error:: x86-only intrinsics header pulled in during preprocessing'; exit 1; fi
          if egrep -qi '(^|[^A-Za-z_])(asm|__asm__)\s*\([^;]*bsf' __pp_probe.i; then
            echo '::error:: x86 asm(bsf) artifacts remain in preprocessed output'; exit 1; fi

      - name: Configure (Meson)
        working-directory: dxvk
        run: |
          set -euo pipefail
          rm -rf build.w64 install || true
          meson setup build.w64 . --cross-file arm64ec.meson --buildtype release --prefix "$PWD/install" -Db_linker=lld
          meson configure build.w64
          meson introspect build.w64 --buildoptions | head -n 120 || true

      - name: Sanity compile & CHPE/ARM64EC check
        working-directory: dxvk
        run: |
          set -Eeuo pipefail
          T=__probe.cc; echo 'int main(){return 0;}' > "$T"
          arm64ec-w64-mingw32-clang++ -v "$T" -o __probe.exe -fuse-ld=lld
          HDR=$(llvm-readobj --file-headers --coff-load-config __probe.exe || true)
          echo "$HDR" | sed -n '1,160p'
          if echo "$HDR" | grep -Eq 'Machine:\s*(IMAGE_FILE_MACHINE_)?ARM64EC'; then
            echo '[sanity] Machine=ARM64EC'
          elif echo "$HDR" | grep -Eq 'Machine:\s*(IMAGE_FILE_MACHINE_)?AMD64' && echo "$HDR" | grep -Eq '(CHPE|ARM64X)'; then
            echo '[sanity] AMD64 header + CHPE/ARM64X metadata (hybrid)'
          else
            echo '::error:: Unexpected machine or missing CHPE metadata'; exit 1
          fi

      - name: Build & Install
        working-directory: dxvk
        run: |
          set -euo pipefail
          meson compile -C build.w64 -v
          meson install -C build.w64

      - name: Verify artifacts machine type + no x86 SIMD residue
        working-directory: dxvk
        run: |
          set -euo pipefail
          shopt -s nullglob
          files=(install/bin/*.dll)
          [ ${#files[@]} -gt 0 ] || { echo '::error::No DLLs found in install/bin'; exit 1; }
          for f in "${files[@]}"; do
            echo "== $f =="
            HDR=$(llvm-readobj --file-headers --coff-load-config "$f" || true)
            echo "$HDR" | sed -n '1,140p'
            if echo "$HDR" | grep -Eq 'Machine:\s*(IMAGE_FILE_MACHINE_)?ARM64EC'; then :; 
            elif echo "$HDR" | grep -Eq 'Machine:\s*(IMAGE_FILE_MACHINE_)?AMD64' && echo "$HDR" | grep -Eq '(CHPE|ARM64X)'; then :; 
            else echo "::error::$f : not ARM64EC/ARM64X"; exit 1; fi
            if llvm-nm -u "$f" | grep -E '_mm_' ; then echo '::error:: unresolved _mm_* symbols present'; exit 1; fi
            if llvm-objdump -d "$f" | grep -Ei 'xmm|ymm|zmm|xmmword|ymmword|zmmword' ; then echo '::warning:: x86 SIMD mnemonics present in disassembly (may be from CHPE regions)'; fi
          done

      - name: Summarize EC build outputs
        working-directory: dxvk
        run: |
          set -euo pipefail
          mkdir -p ../reports
          sha256sum install/bin/*.dll > ../reports/ec_checksums.txt
          for f in install/bin/*.dll; do
            b=$(basename "$f");
            llvm-readobj --coff-exports "$f" | sed 's/\s\+/_/g' | cut -d_ -f2- | sort > ../reports/${b%.dll}.exports
          done

      - name: Upload EC artifacts
        if: ${{ inputs.upload_artifacts }}
        uses: actions/upload-artifact@v4
        with:
          name: ec-dlls
          path: dxvk/install/bin/*.dll

      - name: Upload EC reports
        if: ${{ inputs.upload_artifacts }}
        uses: actions/upload-artifact@v4
        with:
          name: ec-reports
          path: reports/**

  shim-proptests:
    name: Property tests for shim semantics (host x86_64)
    runs-on: ubuntu-24.04
    needs: build-ec
    steps:
      - name: Prepare tests
        run: |
          set -euo pipefail
          mkdir -p tests
          cat > tests/sanity_vec_test.cc <<'CC'
          #include <immintrin.h>
          #include <cstdio>
          #include <cstdint>
          #include <random>
          static inline int mm_movemask_epi8_sse(__m128i a){ return _mm_movemask_epi8(a); }
          int main(){
            std::mt19937_64 rng(0xD1E5A5);
            std::uniform_int_distribution<uint8_t> du8(0,255);
            std::uniform_real_distribution<float> df(-1e3,1e3);
            for(int t=0;t<20000;t++){
              alignas(16) float fa[4]={df(rng),df(rng),df(rng),df(rng)};
              __m128 a=_mm_loadu_ps(fa), b=_mm_loadu_ps(fa);
              __m128 m=_mm_cmpeq_ps(a,b); // self-compare
              alignas(16) unsigned char ba[16];
              for(int i=0;i<16;i++) ba[i]=du8(rng);
              __m128i A=_mm_loadu_si128((const __m128i*)ba);
              volatile int mask=mm_movemask_epi8_sse(A); // use volatile to force calc
              if(mask<0){ puts("neg mask"); return 1; }
            }
            puts("OK");
            return 0;
          }
          CC
          cat > tests/sanity_vec_fb.cc <<'CC'
          #include <cstdio>
          #include <cstdint>
          #include <random>
          struct alignas(16) __m128  { float   v[4];  };
          struct alignas(16) __m128i { uint8_t v[16]; };
          static inline __m128 _mm_loadu_ps(const float* p){ __m128 r; __builtin_memcpy(r.v,p,16); return r; }
          static inline __m128 _mm_cmpeq_ps(__m128 a,__m128 b){ __m128 r; for(int i=0;i<4;i++){ uint32_t m=(a.v[i]==b.v[i])?0xFFFFFFFFu:0u; __builtin_memcpy(&r.v[i],&m,4);} return r; }
          static inline __m128i _mm_loadu_si128(const __m128i* p){ __m128i r; __builtin_memcpy(&r,p,16); return r; }
          static inline int _mm_movemask_epi8(__m128i a){ int m=0; for(int i=0;i<16;i++) m|=((a.v[i]&0x80)?1:0)<<i; return m; }
          int main(){
            std::mt19937_64 rng(0xD1E5A5);
            std::uniform_int_distribution<uint8_t> du8(0,255);
            std::uniform_real_distribution<float> df(-1e3,1e3);
            for(int t=0;t<20000;t++){
              alignas(16) float fa[4]={df(rng),df(rng),df(rng),df(rng)};
              __m128 a=_mm_loadu_ps(fa), b=_mm_loadu_ps(fa);
              __m128 m=_mm_cmpeq_ps(a,b);
              alignas(16) unsigned char ba[16];
              for(int i=0;i<16;i++) ba[i]=du8(rng);
              __m128i A=_mm_loadu_si128((const __m128i*)ba);
              volatile int mask=_mm_movemask_epi8(A);
              if(mask<0){ puts("neg mask"); return 1; }
            }
            puts("OK");
            return 0;
          }
          CC
          cat > tests/bitops_test.cc <<'CC'
          #include <cstdio>
          #include <cstdint>
          #include <random>
          template <class T>
          static inline int sarek_ctz_or_width(T n){
            using U = typename std::make_unsigned<T>::type;
            if(!n) return sizeof(U)*8;
            if constexpr (sizeof(U) <= 4) return __builtin_ctz((unsigned)(U)n);
            else return __builtin_ctzll((unsigned long long)(U)n);
          }
          int main(){
            std::mt19937_64 rng(0xB17B05ULL);
            for(int i=0;i<200000;i++){
              uint64_t x = (rng()<<1) ^ 1ull;
              int r64 = sarek_ctz_or_width(x);
              int r32 = sarek_ctz_or_width((uint32_t)x);
              if(x==0){ if(r64!=64) return 1; } else if(r64<0 || r64>64) return 2;
              if(((uint32_t)x)==0){ if(r32!=32) return 3; } else if(r32<0 || r32>32) return 4;
            }
            puts("OK");
            return 0;
          }
          CC
      - name: Build & run SSE and fallback tests
        run: |
          set -euo pipefail
          g++ -O2 -msse2 -mssse3 tests/sanity_vec_test.cc -o sse_test
          ./sse_test | tee sse.out
          g++ -O2 tests/sanity_vec_fb.cc -o fb_test
          ./fb_test | tee fb.out
          diff -u sse.out fb.out && echo '[vec] SSE vs fallback agree'
          g++ -O2 tests/bitops_test.cc -o bitops
          ./bitops | tee bitops.out
      - name: Upload shim-test logs
        if: ${{ inputs.upload_artifacts }}
        uses: actions/upload-artifact@v4
        with:
          name: shim-tests
          path: |
            sse.out
            fb.out
            bitops.out
