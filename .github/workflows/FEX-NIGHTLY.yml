name: FEXCore-Nightly
# bylaws LLVM_MINGW 20250920
# nightly: builds latest main commit daily; artifact fex-<STABLE>-<YYMMDD>-<shortsha7>.wcp

on:
  workflow_dispatch:
    inputs:
      use_self_hosted:
        type: boolean
        default: false
        description: "true= self-hosted, false= github runner"
      sanitize_llvm_mingw_flags:
        type: boolean
        default: true
        description: "Sanitize llvm-mingw flags"
      revert_p_environ:
        type: boolean
        default: true
        description: "Revert __p__environ import back to local definition"
      arm64ec_module_hotfix:
        type: boolean
        default: true
        description: "ARM64EC Module.S x23â†’x12 hotfix"
  schedule:
    - cron: "0 18 * * *"

permissions:
  contents: read

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  guard:
    name: Nightly gate
    runs-on: ${{ fromJSON( (format('{0}', inputs.use_self_hosted) == 'true' && '["self-hosted"]') || '["ubuntu-latest"]' ) }}
    timeout-minutes: 5
    outputs:
      build:    ${{ steps.decide.outputs.build }}
      date:     ${{ steps.collect.outputs.date }}
      sha:      ${{ steps.collect.outputs.sha }}
      shortsha: ${{ steps.collect.outputs.shortsha }}
      stable:   ${{ steps.collect.outputs.stable }}
      patch:    ${{ steps.collect.outputs.patch }}
      version:  ${{ steps.collect.outputs.version }}
      version_name: ${{ steps.collect.outputs.version_name }}
      version_code: ${{ steps.collect.outputs.version_code }}
    env:
      GH_TOKEN: ${{ github.token }}
      FEX_REPO: ${{ vars.FEX_REPO || 'FEX-Emu/FEX' }}
      RELEASE_TAG: FEXCore-Nightly
    steps:
      - name: Install jq, curl (minimal)
        run: |
          sudo apt-get -yqq update
          sudo apt-get -yqq install --no-install-recommends jq curl ca-certificates

      - name: Collect date (UTC) and latest main commit + compose version
        id: collect
        run: |
          set -Eeuo pipefail
          DATE=$(date -u +%y%m%d)
          echo "date=$DATE" >> "$GITHUB_OUTPUT"

          API="https://api.github.com"
          auth=(-H "Authorization: Bearer ${GH_TOKEN}")
          ver=(-H "Accept: application/vnd.github+json")

          # Get main head SHA
          json=$(curl -fsSL "${auth[@]}" "${ver[@]}" "$API/repos/${FEX_REPO}/commits/main")
          SHA=$(jq -r '.sha' <<<"$json")
          SHORT=${SHA:0:7}

          # Discover stable version from source tags/releases: expect FEX-YYMM(.P)? where P=1..9
          rel=$(curl -fsSL "${auth[@]}" "${ver[@]}" "$API/repos/${FEX_REPO}/releases?per_page=100" || true)
          tags=$(curl -fsSL "${auth[@]}" "${ver[@]}" "$API/repos/${FEX_REPO}/tags?per_page=100" || true)

          candidates=$(
            { jq -r '.[].tag_name // empty' <<<"$rel"; jq -r '.[].name // empty' <<<"$tags"; } \
            | grep -E '^FEX-[0-9]{4}(\.[1-9])?$' | sort -u
          )

          if [[ -z "${candidates}" ]]; then
            echo "::error::No FEX-YYMM(.P) style tags/releases found in ${FEX_REPO}"; exit 1
          fi

          best=$(printf '%s\n' "$candidates" | awk -F'-' '
                      {
                        n=$2
                        split(n, a, ".")
                        base=a[1]
                        p=a[2]
                        pv = (p == "" ? 0 : p)
                        if (base ~ /^[0-9]{4}$/ && (p == "" || p ~ /^[1-9]$/)) {
                          key = base*10 + pv
                          if (key>max) { max=key; b=base; patch=p }
                        }
                      }
                      END {
                        if (max=="") exit 1;
                        if (patch=="") printf("%s", b); else printf("%s.%s", b, patch);
                      }
                    ')

          STABLE="$best"

          if [[ "$STABLE" =~ ^([0-9]{4})(\.[1-9])?$ ]]; then
            PATCH="${BASH_REMATCH[2]#.}"
          else
            echo "::error::Invalid stable derived from tag: '$STABLE'"; exit 1
          fi

          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "shortsha=$SHORT" >> "$GITHUB_OUTPUT"
          echo "stable=$STABLE" >> "$GITHUB_OUTPUT"
          echo "patch=$PATCH" >> "$GITHUB_OUTPUT"

          VERSION="${STABLE}-${DATE}-${SHORT}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          VERSION_NAME="${STABLE}-${SHORT}"
          VERSION_CODE="$DATE"
          echo "version_name=$VERSION_NAME" >> "$GITHUB_OUTPUT"
          echo "version_code=$VERSION_CODE" >> "$GITHUB_OUTPUT"
          echo "Current UTC date: $DATE, head: $SHORT, version: $VERSION"

      - name: Check existing release assets/body
        id: have
        env:
          VERSION: ${{ steps.collect.outputs.version }}
        run: |
          set -Eeuo pipefail
          API="https://api.github.com"
          auth=(-H "Authorization: Bearer ${GH_TOKEN}")
          ver=(-H "Accept: application/vnd.github+json")
          HTTP=$(curl -s -o /tmp/rel.json -w '%{http_code}' "${auth[@]}" "${ver[@]}" \
                 "$API/repos/${{ github.repository }}/releases/tags/${RELEASE_TAG}" || true)
          if [ "$HTTP" = "200" ]; then
            WANT="fex-${VERSION}.wcp"
            HAVE_ASSET=$(jq -r --arg fn "$WANT" '.assets[]?.name | select(.==$fn)' /tmp/rel.json | head -n1)
            LAST_COMMIT=$(jq -r '.body' /tmp/rel.json \
              | sed -n -E '/^[[:space:]]*Current:/ s/.*\[([0-9a-f]{7,40})\].*/\1/p' | head -n1)
          else
            HAVE_ASSET=""
            LAST_COMMIT=""
          fi
          echo "have_asset=${HAVE_ASSET}" >> "$GITHUB_OUTPUT"
          echo "last_commit=${LAST_COMMIT}" >> "$GITHUB_OUTPUT"
          echo "HTTP=$HTTP, HAVE_ASSET=${HAVE_ASSET:-none}, LAST_COMMIT=${LAST_COMMIT:-none}"

      - name: Decide build or skip
        id: decide
        env:
          SHA:         ${{ steps.collect.outputs.sha }}
          HAVE_ASSET:  ${{ steps.have.outputs.have_asset }}
          LAST_COMMIT: ${{ steps.have.outputs.last_commit }}
        run: |
          set -Eeuo pipefail
          do_build=true
          if [ -n "$HAVE_ASSET" ]; then
            echo "::notice::Asset already exists ($HAVE_ASSET). Skipping."
            do_build=false
          elif [ -n "$LAST_COMMIT" ] && { [ "$LAST_COMMIT" = "$SHA" ] || [ "$LAST_COMMIT" = "${SHA:0:7}" ]; }; then
            echo "::notice::Same commit already built. Skipping."
            do_build=false
          fi
          echo "build=$do_build" >> "$GITHUB_OUTPUT"

  build-and-release:
    name: Build & release nightly
    runs-on: ${{ fromJSON( (format('{0}', inputs.use_self_hosted) == 'true' && '["self-hosted"]') || '["ubuntu-latest"]' ) }}
    needs: guard
    if: needs.guard.outputs.build == 'true'
    timeout-minutes: 60
    permissions:
      contents: write
    env:
      FEX_REPO: ${{ vars.FEX_REPO || 'FEX-Emu/FEX' }}
      TOOLCHAIN_DIR: /opt/llvm-mingw
      RELEASE_TAG: FEXCore-Nightly
      GH_TOKEN: ${{ github.token }}
      LLVM_MINGW_TAG: ${{ vars.LLVM_MINGW_TAG || '20250920' }}
      VERSION: ${{ needs.guard.outputs.version }}
      VERSION_NAME: ${{ needs.guard.outputs.version_name }}
      VERSION_CODE: ${{ needs.guard.outputs.version_code }}
      STABLE: ${{ needs.guard.outputs.stable }}
      SHORTSHA: ${{ needs.guard.outputs.shortsha }}
      DATE: ${{ needs.guard.outputs.date }}
      DO_SANITIZE: ${{ (github.event_name != 'workflow_dispatch') || inputs.sanitize_llvm_mingw_flags }}
      DO_PENVIRON: ${{ (github.event_name != 'workflow_dispatch') || inputs.revert_p_environ }}
      DO_EC_HOTFIX: ${{ (github.event_name != 'workflow_dispatch') || inputs.arm64ec_module_hotfix }}
    steps:
      - name: Install host tooling (lean set; no cache)
        run: |
          sudo apt-get -yqq update
          sudo apt-get -yqq install --no-install-recommends \
            curl xz-utils jq ca-certificates \
            git ninja-build cmake pkg-config \
            build-essential python3 zstd gh perl dos2unix

      - name: Download pinned llvm-mingw
        env:
          TAG: ${{ env.LLVM_MINGW_TAG }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -Eeuo pipefail
          gh release download "$TAG" -R bylaws/llvm-mingw \
            -p '*ucrt-ubuntu-22.04-x86_64.tar.xz' -O /tmp/llvm-mingw.tar.xz --clobber
          sudo mkdir -p /opt/llvm-mingw
          sudo tar -C /opt/llvm-mingw --strip-components=1 -xJf /tmp/llvm-mingw.tar.xz
          echo "/opt/llvm-mingw/bin" >> "$GITHUB_PATH"

      - name: Pre-clean workspace (self-hosted)
        run: |
          set -Eeuo pipefail
          test -n "${GITHUB_WORKSPACE}" && test -d "${GITHUB_WORKSPACE}"
          rm -rf "${GITHUB_WORKSPACE}/src" \
                 "${GITHUB_WORKSPACE}/FEXCore_WCP" \
                 "${GITHUB_WORKSPACE}/out"

      - name: Clone FEX at decided commit
        env:
          SHA: ${{ needs.guard.outputs.sha }}
        run: |
          set -Eeuo pipefail
          git init src
          git -C src remote add origin https://github.com/${FEX_REPO}.git
          git -C src -c protocol.version=2 fetch --depth=1 --filter=blob:none origin "$SHA"
          git -C src checkout --detach FETCH_HEAD
          git -C src submodule update --init --recursive --depth=1 --recommend-shallow

      - name: Configure git identity
        run: |
          git -C src config user.name "FEXCore Nightly Builder"
          git -C src config user.email "builder@users.noreply.github.com"

      - name: Sanitize llvm-mingw flags (keep -static, drop GCC-only & -lucrtbase)
        if: ${{ env.DO_SANITIZE == 'true' }}
        run: |
          set -Eeuo pipefail
          T="${GITHUB_WORKSPACE}/src/Data/CMake/toolchain_mingw.cmake"
          [[ -f "$T" ]] || { echo "::error::toolchain file not found: $T"; exit 1; }
      
          grep -Fq 'CMAKE_SHARED_LINKER_FLAGS_INIT' "$T" || { echo "::error::Missing SHARED INIT"; exit 1; }
          grep -Fq 'CMAKE_EXE_LINKER_FLAGS_INIT' "$T" || { echo "::error::Missing EXE INIT"; exit 1; }
      
          perl -0777 -i -pe 's/\Q-static-libgcc \E//g; s/\Q-static-libstdc++ \E//g' "$T"
          perl -0777 -i -pe 's/(^|\s)-lucrtbase(\s|$)/ /g' "$T"

          if grep -Eq -- '-static-lib(gcc|stdc\+\+)([[:space:]]|$)' "$T"; then
            echo "::error::GCC-only purge failed"; exit 1
          fi
          
          if grep -Eq -- '(^|[[:space:]])-lucrtbase([[:space:]]|$)' "$T"; then
            echo "::error::-lucrtbase still present"; exit 1
          fi
      
      - name: Revert __p__environ import back to local definition (if present)
        if: ${{ env.DO_PENVIRON == 'true' }}
        run: |
          set -Eeuo pipefail
          F="${GITHUB_WORKSPACE}/src/Source/Windows/Common/CRT/Misc.cpp"
          [[ -f "$F" ]] || { echo "::error::File not found: $F"; exit 1; }

          if grep -Fxq 'extern "C" __declspec(dllimport) char*** __cdecl __p__environ(void);' "$F"; then
            perl -0777 -i -pe 's{^\Qextern "C" __declspec(dllimport) char*** __cdecl __p__environ(void);\E$}{char*** __p__environ() {\n  return &EnvArray;\n}}m' "$F"
            grep -Fxq 'char*** __p__environ() {' "$F" || { echo "::error::Restore failed"; exit 1; }
          else
            echo "::notice::__p__environ already local; nothing to revert"
          fi

      - name: ARM64EC Module.S x23â†’x12 hotfix (strict, no-heredoc)
        if: ${{ env.DO_EC_HOTFIX == 'true' }}
        run: |
          set -Eeuo pipefail
          FILE="${GITHUB_WORKSPACE}/src/Source/Windows/ARM64EC/Module.S"
          [[ -f "$FILE" ]] || { echo "::error::File not found: $FILE"; exit 1; }

          L1='  ldursw x23, [x17, #-0x4] // Load either the entry thunk offset or the calling instruction.'
          L2='  cmp w23, w16'
          L3='  and x23, x23, #-0x4'
          L4='  add x17, x17, x23 // Resolve entry thunk address.'
      
          for n in "$L1" "$L2" "$L3" "$L4"; do
            grep -Fqx -- "$n" "$FILE" || { echo "::error::Upstream drift in $FILE (expected line missing): [$n]"; exit 1; }
          done
 
          perl -0777 -i -pe 's{^\Q  ldursw x23, [x17, #-0x4] // Load either the entry thunk offset or the calling instruction.\E$}{  ldursw x12, [x17, #-0x4] // Load either the entry thunk offset or the calling instruction. [CI hotfix: x23->x12]}m; s{^\Q  cmp w23, w16\E$}{  cmp w12, w16}m; s{^\Q  and x23, x23, #-0x4\E$}{  and x12, x12, #-0x4}m; s{^\Q  add x17, x17, x23 // Resolve entry thunk address.\E$}{  add x17, x17, x12 // Resolve entry thunk address.}m;' "$FILE"
      

          NEW1='  ldursw x12, [x17, #-0x4] // Load either the entry thunk offset or the calling instruction. [CI hotfix: x23->x12]'
          NEW2='  cmp w12, w16'
          NEW3='  and x12, x12, #-0x4'
          NEW4='  add x17, x17, x12 // Resolve entry thunk address.'
      
          for n in "$NEW1" "$NEW2" "$NEW3" "$NEW4"; do
            grep -Fqx -- "$n" "$FILE" || { echo "::error::Patched line missing: [$n]"; exit 1; }
          done
          for n in "$L1" "$L2" "$L3" "$L4"; do
            ! grep -Fqx -- "$n" "$FILE" || { echo "::error::Old line still present after patch: [$n]"; exit 1; }
          done
      
          echo "::notice::Applied strict Module.S hotfix at $FILE"

      - name: Build (ARM64EC + AArch64)
        run: |
          set -Eeuo pipefail
          cd "${GITHUB_WORKSPACE}/src"

          # Stage dirs for split installs
          STAGE_ARM64EC="${GITHUB_WORKSPACE}/stage-arm64ec-${DATE}"
          STAGE_AARCH64="${GITHUB_WORKSPACE}/stage-aarch64-${DATE}"
          rm -rf "$STAGE_ARM64EC" "$STAGE_AARCH64"
          mkdir -p "$STAGE_ARM64EC" "$STAGE_AARCH64"

          # Build: ARM64EC (x86_64 emu module)
          rm -rf build-arm64ec && mkdir build-arm64ec && cd build-arm64ec
          cmake -GNinja \
            --log-level=WARNING \
            -Wno-dev \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_TOOLCHAIN_FILE=../Data/CMake/toolchain_mingw.cmake \
            -DCMAKE_INSTALL_LIBDIR=/usr/lib/wine/aarch64-windows \
            -DENABLE_LTO=False \
            -DMINGW_TRIPLE=arm64ec-w64-mingw32 \
            -DBUILD_TESTING=False -DBUILD_TESTS=False \
            -DENABLE_JEMALLOC_GLIBC_ALLOC=False \
            -DCMAKE_C_FLAGS="${CFLAGS:+$CFLAGS }-D_CRTIMP= -D_SECIMP=" \
            -DCMAKE_CXX_FLAGS="${CXXFLAGS:+$CXXFLAGS }-D_CRTIMP= -D_SECIMP=" \
            -DCMAKE_INSTALL_PREFIX=/usr ..
          NINJA_STATUS="" ninja
          DESTDIR="$STAGE_ARM64EC" ninja install
          cd ..

          # ---- revert ARM64EC hotfix: keep tree clean for AArch64 ----
          git -C "${GITHUB_WORKSPACE}/src" restore --source=HEAD -- "Source/Windows/ARM64EC/Module.S" \
            || git -C "${GITHUB_WORKSPACE}/src" checkout -- "Source/Windows/ARM64EC/Module.S"
          echo "::notice::Reverted Module.S to HEAD for AArch64 build"
          # ------------------------------------------------------------

          # Build: AArch64 (WOW64 emu module)
          rm -rf build-wow64 && mkdir build-wow64 && cd build-wow64
          cmake -GNinja \
            --log-level=WARNING \
            -Wno-dev \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_TOOLCHAIN_FILE=../Data/CMake/toolchain_mingw.cmake \
            -DCMAKE_INSTALL_LIBDIR=/usr/lib/wine/aarch64-windows \
            -DENABLE_LTO=False \
            -DMINGW_TRIPLE=aarch64-w64-mingw32 \
            -DBUILD_TESTING=False -DBUILD_TESTS=False \
            -DENABLE_JEMALLOC_GLIBC_ALLOC=False \
            -DCMAKE_C_FLAGS="${CFLAGS:+$CFLAGS }-D_CRTIMP= -D_SECIMP=" \
            -DCMAKE_CXX_FLAGS="${CXXFLAGS:+$CXXFLAGS }-D_CRTIMP= -D_SECIMP=" \
            -DCMAKE_INSTALL_PREFIX=/usr ..
          NINJA_STATUS="" ninja
          DESTDIR="$STAGE_AARCH64" ninja install
          cd ..

          # Package WCP (system32 only)
          WCP_DIR="${GITHUB_WORKSPACE}/FEXCore_WCP"
          rm -rf "$WCP_DIR" && mkdir -p "$WCP_DIR/system32"

          for ST in "$STAGE_ARM64EC" "$STAGE_AARCH64"; do
            SRC="$ST/usr/lib/wine/aarch64-windows"
            if [[ -d "$SRC" ]]; then
              find "$SRC" -type f -name '*.dll' -exec cp {} "$WCP_DIR/system32/" \;
            else
              echo "::warning::Expected install dir not found: $SRC"
            fi
          done

          if command -v llvm-strip >/dev/null 2>&1; then
            find "$WCP_DIR/system32" -type f -name '*.dll' -print0 | xargs -0 -I{} llvm-strip -s "{}" || true
          fi

          (cd "$WCP_DIR" && find system32 -maxdepth 1 -type f -name '*.dll' -printf '%f\n' | LC_ALL=C sort) > /tmp/s32.txt || true
          test -s /tmp/s32.txt || { echo "::error::No DLLs discovered in system32"; exit 1; }

          VER="$VERSION"
          VER_NAME="${VERSION_NAME:-${STABLE}-${SHORTSHA}}"
          VC="${VERSION_CODE:-$DATE}"

          jq -n \
            --arg VER_NAME "$VER_NAME" \
            --arg DESC "FEXCore-Nightly $VERSION Automated Build (Built by Ari's Winlator WCP Hub. Upstream: bylaws)" \
            --argjson VC "$VC" \
            --slurpfile S32 <(find "$WCP_DIR/system32" -maxdepth 1 -type f -name '*.dll' -printf '%f\n' \
                              | jq -Rn '[inputs | {source: ("system32/"+.), target: ("${system32}/"+.)}]') \
            '{
              type: "FEXCore",
              versionName: $VER_NAME,
              versionCode: $VC,
              description: $DESC,
              files: ($S32[0] // [])
            }' > "$WCP_DIR/profile.json"

          OUT="${GITHUB_WORKSPACE}/out"; mkdir -p "$OUT"
          tar --zstd -C "$WCP_DIR" \
            --format=gnu --owner=0 --group=0 --numeric-owner \
            --sort=name \
            -cf "$OUT/fex-${VER}.wcp" profile.json system32

      - name: Build release notes
        env:
          SHORTSHA: ${{ needs.guard.outputs.shortsha }}
          VERSION:  ${{ needs.guard.outputs.version }}
        run: |
          set -Eeuo pipefail
          NOTES="${GITHUB_WORKSPACE}/RELEASE_NOTES.md"
          printf 'ðŸŒ™ Automated FEXCore nightly builds (rolling)\n\n' > "$NOTES"
          echo "Current: ${STABLE}-${DATE}(YYMMDD)-[${SHORTSHA}](https://github.com/FEX-Emu/FEX/commit/${SHORTSHA})" >> "$NOTES"
          cat "$NOTES"

      - name: Create/Update GitHub Release (Nightly) + upload WCP
        env:
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -Eeuo pipefail
          NOTES="${GITHUB_WORKSPACE}/RELEASE_NOTES.md"
          RELEASE_TAG="${RELEASE_TAG}"

          if ! gh release view "${RELEASE_TAG}" --repo "${REPO}" >/dev/null 2>&1; then
            gh release create "${RELEASE_TAG}" --repo "${REPO}" -t "${RELEASE_TAG}" -F "$NOTES"
          else
            gh release edit   "${RELEASE_TAG}" --repo "${REPO}" -t "${RELEASE_TAG}" -F "$NOTES"
          fi

          if compgen -G "${GITHUB_WORKSPACE}/out/*.wcp" > /dev/null; then
            gh release upload "${RELEASE_TAG}" "${GITHUB_WORKSPACE}/out/"*.wcp --repo "${REPO}" --clobber
          else
            echo "No new WCP files to upload."
          fi
