name: Box64-Bionic Nightly
#Fix -Wformat on Android/Clang: replace sprintf with snprintf and cast Elf64*/__u64 fields to match PRIx64/PRIu64 in elfload_dump.c/env.c.

on:
  workflow_dispatch:
    inputs:
      use_self_hosted:
        type: boolean
        default: false
        description: "true= self-hosted, false= github runner"
  schedule:
    - cron: "0 18 * * *"

permissions:
  contents: read

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  guard:
    name: Nightly gate (UTC, dual checks)
    runs-on: ${{ fromJSON( (format('{0}', inputs.use_self_hosted) == 'true' && '["self-hosted"]') || '["ubuntu-latest"]' ) }}
    timeout-minutes: 5
    outputs:
      build:        ${{ steps.decide.outputs.build }}
      sha:          ${{ steps.upstream.outputs.sha }}
      short:        ${{ steps.upstream.outputs.short }}
      datecode:     ${{ steps.date.outputs.datecode }}
      stable:       ${{ steps.ver.outputs.stable }}
      stable_tag:   ${{ steps.ver.outputs.stable_tag }}
      develop:      ${{ steps.ver.outputs.develop }}
      version_name: ${{ steps.compose.outputs.version_name }}
      version_code: ${{ steps.date.outputs.datecode }}
      filename:     ${{ steps.compose.outputs.filename }}
    env:
      GH_TOKEN: ${{ github.token }}
      RELEASE_TAG: BOX64-BIONIC-NIGHTLY
      OWNER: ptitSeb
      REPO: box64
    steps:
      - name: Install jq, curl (minimal)
        run: |
          sudo apt-get -yqq update
          sudo apt-get -yqq install --no-install-recommends jq curl ca-certificates

      - name: Resolve upstream default branch HEAD
        id: upstream
        run: |
          set -Eeuo pipefail
          API="https://api.github.com"
          auth=(-H "Authorization: Bearer ${GH_TOKEN}")
          ua=(-H "User-Agent: ${GITHUB_REPOSITORY:-box64-bionic-nightly}")
          ver=(-H "X-GitHub-Api-Version: 2022-11-28" -H "Accept: application/vnd.github+json")
          fetch() { curl -fsSL --retry 6 --retry-delay 2 --retry-all-errors "${auth[@]}" "${ua[@]}" "${ver[@]}" "$1"; }

          default_branch="$(fetch "$API/repos/${OWNER}/${REPO}" | jq -r .default_branch)"
          [[ -z "$default_branch" || "$default_branch" == "null" ]] && default_branch="main"

          sha="$(fetch "$API/repos/${OWNER}/${REPO}/commits/${default_branch}" | jq -r .sha)"
          [[ -z "$sha" || "$sha" == "null" ]] && { echo "::error::Failed to resolve upstream HEAD SHA"; exit 1; }

          short="${sha:0:7}"
          echo "sha=${sha}"   >> "$GITHUB_OUTPUT"
          echo "short=${short}" >> "$GITHUB_OUTPUT"
          echo "Upstream ${default_branch} @ ${short}"

      - name: Resolve latest stable tag and derive develop (evenâ†’odd)
        id: ver
        run: |
          set -Eeuo pipefail
          API="https://api.github.com"
          auth=(-H "Authorization: Bearer ${GH_TOKEN}")
          ua=(-H "User-Agent: ${GITHUB_REPOSITORY:-box64-bionic-nightly}")
          ver=(-H "X-GitHub-Api-Version: 2022-11-28" -H "Accept: application/vnd.github+json")
          fetch() { curl -fsSL --retry 6 --retry-delay 2 --retry-all-errors "${auth[@]}" "${ua[@]}" "${ver[@]}" "$1"; }

          releases="$(fetch "$API/repos/${OWNER}/${REPO}/releases?per_page=100")"
          stable_tag="$(
            jq -r '
              [ .[] | select(.draft==false)
                | .tag_name
                | select(test("^v[0-9]+\\.[0-9]+\\.[0-9]+$"))
                | capture("^v(?<maj>[0-9]+)\\.(?<min>[0-9]+)\\.(?<pat>[0-9]+)$")
                | .maj|=tonumber | .min|=tonumber | .pat|=tonumber
              ]
              | sort_by(.maj, .min, .pat)
              | last
              | if . then "v\(.maj).\(.min).\(.pat)" else "" end
            ' <<<"$releases"
          )"
          [[ -n "$stable_tag" ]] || { echo "::error::Failed to resolve latest stable tag"; exit 1; }

          stable="${stable_tag#v}"
          IFS=. read -r MAJ MIN PAT <<<"$stable"
          DEV_PATCH=$((PAT + 1))
          DEV="${MAJ}.${MIN}.${DEV_PATCH}"

          echo "stable=${stable}"       >> "$GITHUB_OUTPUT"
          echo "stable_tag=${stable_tag}" >> "$GITHUB_OUTPUT"
          echo "develop=${DEV}"         >> "$GITHUB_OUTPUT"
          echo "Stable=${stable_tag}, Develop=${DEV}"

      - name: Decide date code (UTC)
        id: date
        run: echo "datecode=$(date -u +%y%m%d)" >> "$GITHUB_OUTPUT"

      - name: Compose version strings & filename
        id: compose
        env:
          SHORT:    ${{ steps.upstream.outputs.short }}
          DEV:      ${{ steps.ver.outputs.develop }}
          DATECODE: ${{ steps.date.outputs.datecode }}
        run: |
          set -Eeuo pipefail
          VERSION_NAME="${DEV}-${SHORT}"
          FILENAME="box64-bionic-${DEV}-${DATECODE}-${SHORT}.wcp"
          echo "version_name=${VERSION_NAME}" >> "$GITHUB_OUTPUT"
          echo "filename=${FILENAME}"         >> "$GITHUB_OUTPUT"
          echo "Composed: ${FILENAME}"

      - name: Check existing release assets/body
        id: have
        env:
          REPO_FULL: ${{ github.repository }}
          FILENAME:  ${{ steps.compose.outputs.filename }}
          SHA:       ${{ steps.upstream.outputs.sha }}
          SHORT:     ${{ steps.upstream.outputs.short }}
        run: |
          set -Eeuo pipefail
          API="https://api.github.com/repos/${REPO_FULL}/releases/tags/${RELEASE_TAG}"
          HTTP="$(curl -s -o /tmp/rel.json -w '%{http_code}' -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" "$API" || true)"
          if [ "$HTTP" = "200" ]; then
            HAVE_ASSET="$(jq -r --arg N "$FILENAME" '[.assets[]?.name] | index($N) | if .==null then "false" else "true" end' /tmp/rel.json)"
            SAME_COMMIT="$(jq -r --arg S "$SHA" --arg SS "$SHORT" '((.body // "") | contains($S) or contains($SS)) | tostring' /tmp/rel.json)"
          else
            HAVE_ASSET="false"; SAME_COMMIT="false"
          fi
          echo "have_asset=${HAVE_ASSET}"   >> "$GITHUB_OUTPUT"
          echo "same_commit=${SAME_COMMIT}" >> "$GITHUB_OUTPUT"
          echo "HTTP=$HTTP, HAVE_ASSET=${HAVE_ASSET}, SAME_COMMIT=${SAME_COMMIT}"

      - name: Decide build or skip
        id: decide
        env:
          HAVE: ${{ steps.have.outputs.have_asset }}
          SAME: ${{ steps.have.outputs.same_commit }}
        run: |
          set -Eeuo pipefail
          do_build=true
          if [ "$HAVE" = "true" ]; then
            echo "::notice::Asset already exists. Skipping."
            do_build=false
          elif [ "$SAME" = "true" ]; then
            echo "::notice::Same commit already recorded in release body. Skipping."
            do_build=false
          fi
          echo "build=${do_build}" >> "$GITHUB_OUTPUT"

  build-and-release:
    name: Build & release ${{ needs.guard.outputs.short }}
    needs: [guard]
    if: needs.guard.outputs.build == 'true'
    runs-on: ${{ fromJSON( (format('{0}', inputs.use_self_hosted) == 'true' && '["self-hosted"]') || '["ubuntu-latest"]' ) }}
    timeout-minutes: 60
    permissions:
      contents: write
    env:
      GH_TOKEN:  ${{ github.token }}
      REPO_FULL: ${{ github.repository }}
      OWNER:     ptitSeb
      REPO:      box64
      RELEASE_TAG: BOX64-BIONIC-NIGHTLY
      NDK_VERSION: r26b
      API_LEVEL: 31
      BUILD_TYPE: Release
      SHA:       ${{ needs.guard.outputs.sha }}
      SHORT:     ${{ needs.guard.outputs.short }}
      DATECODE:  ${{ needs.guard.outputs.datecode }}
      DEV:       ${{ needs.guard.outputs.develop }}
      FILENAME:  ${{ needs.guard.outputs.filename }}
    steps:
      - name: Install build deps (lean)
        run: |
          sudo apt-get -yqq update
          sudo apt-get -yqq install --no-install-recommends \
            git cmake make ninja-build python3 zstd file jq curl unzip ca-certificates \
            binutils

      - name: Checkout upstream Box64 (exact commit)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.OWNER }}/${{ env.REPO }}
          ref: ${{ env.SHA }}
          submodules: recursive
          path: src
          fetch-depth: 1

      - name: Prepare Android NDK ${{ env.NDK_VERSION }} (idempotent)
        run: |
          set -Eeuo pipefail
          NDK_BASE="android-ndk-${NDK_VERSION}"
          URL="https://dl.google.com/android/repository/${NDK_BASE}-linux.zip"
          NDK_DIR="${RUNNER_TEMP:-$PWD}/${NDK_BASE}"

          if [[ -d "$NDK_DIR" && ! -x "$NDK_DIR/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android${API_LEVEL}-clang" ]]; then
            echo "::warning::Stale or partial NDK at $NDK_DIR; removing"
            rm -rf "$NDK_DIR"
          fi

          if [[ ! -d "$NDK_DIR" ]]; then
            curl -fsSL -o ndk.zip "$URL"
            unzip -q -o ndk.zip -d "${RUNNER_TEMP:-$PWD}"
          else
            echo "Reusing existing NDK at $NDK_DIR"
          fi

          echo "NDK=$NDK_DIR" >> $GITHUB_ENV
          echo "BOX64_COMPILER=$NDK_DIR/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android${API_LEVEL}-clang" >> $GITHUB_ENV
          echo "BOX64_PLATFORM_MACRO=-DANDROID=1 -DARM_DYNAREC=1 -DBAD_SIGNAL=1" >> $GITHUB_ENV

      - name: Fix 64-bit printf formats in elfload_dump.c (+env.c), incl. s->d_tag for PRIX64
        working-directory: src
        run: |
          set -Eeuo pipefail
      
          FILE_ELF="$(git ls-files | grep -E '/elfs/elfload_dump\.c$' | head -n1 || true)"
          FILE_ENV="$(git ls-files | grep -E '/tools/env\.c$'        | head -n1 || true)"
      
          if [[ -z "$FILE_ELF" || ! -f "$FILE_ELF" ]]; then
            echo "::error::elfload_dump.c not found"; git ls-files | sed -n '1,200p'; exit 1
          fi
          [[ -n "$FILE_ENV" ]] || echo "::notice::tools/env.c not found; skipping that part"
      
          echo "ELF file: $FILE_ELF"
          [[ -n "$FILE_ENV" ]] && echo "ENV file: $FILE_ENV"
      
          # 0) PRI*
          for f in "$FILE_ELF" ${FILE_ENV:-}; do
            [[ -n "$f" ]] || continue
            if ! grep -qE '#include[[:space:]]*<inttypes\.h>' "$f"; then
              awk 'NR==1{print "#include <inttypes.h>"}{print}' "$f" > "$f.new" && mv "$f.new" "$f"
            fi
          done
      
          # 1) elfload_dump.c: sprintf â†’ snprintf(â€¦, sizeof(buff), â€¦)
          sed -i -E 's/\bsprintf\([[:space:]]*buff,[[:space:]]*/snprintf(buff, sizeof(buff), /g' "$FILE_ELF"
      
          # 2)
          sed -i -E 's/\(Add\)\?s->d_un\.d_ptr:s->d_un\.d_val/(uint64_t)((Add)?s->d_un.d_ptr:s->d_un.d_val)/g' "$FILE_ELF"
      
          # 3)
          sed -i 's/\be->p_offset\b/(uint64_t)e->p_offset/g' "$FILE_ELF"
          sed -i 's/\be->p_filesz\b/(uint64_t)e->p_filesz/g' "$FILE_ELF"
          sed -i 's/\be->p_memsz\b/(uint64_t)e->p_memsz/g'   "$FILE_ELF"
          sed -i 's/\be->p_align\b/(uint64_t)e->p_align/g'   "$FILE_ELF"
      
          # 4)
          sed -i -E 's/([^[:alnum:]_])s->sh_offset([^[:alnum:]_])/\1(unsigned long)s->sh_offset\2/g'      "$FILE_ELF"
          sed -i -E 's/([^[:alnum:]_])s->sh_size([^[:alnum:]_])/\1(unsigned long)s->sh_size\2/g'          "$FILE_ELF"
          sed -i -E 's/([^[:alnum:]_])s->sh_flags([^[:alnum:]_])/\1(unsigned long)s->sh_flags\2/g'        "$FILE_ELF"
          sed -i -E 's/([^[:alnum:]_])s->sh_addralign([^[:alnum:]_])/\1(unsigned long)s->sh_addralign\2/g' "$FILE_ELF"
      
          # 5)
          sed -i -E 's/([^[:alnum:]_])sym->st_size([^[:alnum:]_])/\1(unsigned long)sym->st_size\2/g' "$FILE_ELF"
      
          # 6)
          sed -i -E 's/(unknown type"[[:space:]]*,[[:space:]]*)s->d_tag/\1(uint64_t)s->d_tag/' "$FILE_ELF"

          sed -i -E 's/(PRIX64[^,]*,[[:space:]]*)s->d_tag/\1(uint64_t)s->d_tag/g' "$FILE_ELF"

          awk -v OFS="" '
            /PRIX64/ && /d_tag/ {
              if ($0 !~ /\(uint64_t\)[[:space:]]*s->d_tag/) gsub(/s->d_tag/,"(uint64_t)s->d_tag");
            }
            { print }
          ' "$FILE_ELF" > "$FILE_ELF.new" && mv "$FILE_ELF.new" "$FILE_ELF"
      
          # 7) env.c: %llx â†’ %" PRIx64
          if [[ -n "$FILE_ENV" ]]; then
            sed -i 's|"%s-%llx-%u"|"%s-%" PRIx64 "-%u"|g' "$FILE_ENV"
            sed -i 's/, *dynarec_settings,/, (uint64_t)dynarec_settings,/g' "$FILE_ENV"
          fi
      
          # 8)
          if grep -nE '\bsprintf\([[:space:]]*buff,' "$FILE_ELF"; then
            echo "::error::elfload_dump.c still uses sprintf(buff, ...)"; exit 1
          fi

          if awk '
              /\?s->d_un\.d_ptr:s->d_un\.d_val/ &&
              $0 !~ /\(uint64_t\)[[:space:]]*\(\(Add\)\?s->d_un\.d_ptr:s->d_un\.d_val\)/
            { print "uncasted d_un ternary at:", NR ":" $0; bad=1 }
            END{ exit bad }
          ' "$FILE_ELF"
          then
            echo "::error::un-cast dynamic value (d_un) present"; exit 1
          fi

          if grep -nE 'PRIX64[^,]*,[[:space:]]*s->d_tag' "$FILE_ELF"; then
            echo "::error::s->d_tag still uncast with PRIX64"; exit 1
          fi
      
          echo "Hotfixes applied cleanly on: $FILE_ELF"

      - name: Configure (CMake)
        run: |
          set -Eeuo pipefail
          cd src
          mkdir -p build && cd build
          cmake .. \
            -G Ninja \
            -DCMAKE_C_COMPILER="${BOX64_COMPILER}" \
            ${BOX64_PLATFORM_MACRO} \
            -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
            -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON \
            -DZYDIS3=0 \
            -DSTATICBUILD=0 \
            -DBOX32=0

      - name: Build (parallel)
        run: cmake --build src/build -j"$(nproc)"

      - name: Strip binary (safe)
        run: |
          set -Eeuo pipefail
          BIN="src/build/box64"
          [[ -f "$BIN" ]] || { echo "::error::Missing binary: $BIN"; exit 1; }
          STRIP_BIN="${NDK}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip"
          if [[ -x "$STRIP_BIN" ]]; then
            "$STRIP_BIN" --strip-unneeded "$BIN"
          else
            strip --strip-unneeded "$BIN"
          fi
          file "$BIN"

      - name: Verify ELF (Bionic traits)
        run: |
          set -Eeuo pipefail
          echo "---- INTERP ----"
          readelf -lW src/build/box64 | sed -n 's/.*Requesting program interpreter: *//p'
          echo "---- NEEDED ----"
          readelf -dW src/build/box64 | awk '/NEEDED/{print $0}'
          echo "---- ANDROID NOTE ----"
          readelf -nW src/build/box64 | sed -n '/.note.android.ident/,/Displaying/p'

      - name: Package WCP (develop semver + date + short)
        run: |
          set -Eeuo pipefail
          mkdir -p Box64_WCP artifacts
          cp src/build/box64 Box64_WCP/box64
          chmod +x Box64_WCP/box64 || true

          cat > Box64_WCP/profile.json <<JSON
          {
            "type": "Box64",
            "versionName": "${DEV}-${SHORT}",
            "versionCode": ${DATECODE},
            "description": "Box64-Bionic-Nightly ${DEV}-${SHORT} Automated Build (Upstream: ptitSeb)",
            "files": [
              { "source": "box64", "target": "\${bindir}/box64" }
            ]
          }
          JSON

          (cd Box64_WCP && tar --zstd --format=gnu --owner=0 --group=0 --numeric-owner --sort=name \
                -cf "../artifacts/${FILENAME}" profile.json box64)

      - name: Create/Update release and upload
        env:
          NOTES_FILE: ${{ runner.temp }}/RELEASE_NOTES.md
        run: |
          set -Eeuo pipefail
          printf 'ðŸŒ™ Automated BOX64 Bionic nightly builds (rolling)\n\n' > "$NOTES_FILE"
          echo "Current: ${DEV}-${DATECODE}(YYMMDD)-[${SHORT}](https://github.com/${OWNER}/${REPO}/commit/${SHA})" >> "$NOTES_FILE"

          if ! gh release view "${RELEASE_TAG}" --repo "${REPO_FULL}" >/dev/null 2>&1; then
            gh release create "${RELEASE_TAG}" --repo "${REPO_FULL}" -t "${RELEASE_TAG}" -F "$NOTES_FILE"
          else
            gh release edit   "${RELEASE_TAG}" --repo "${REPO_FULL}" -t "${RELEASE_TAG}" -F "$NOTES_FILE"
          fi

          gh release upload "${RELEASE_TAG}" "./artifacts/${FILENAME}" --repo "${REPO_FULL}" --clobber
